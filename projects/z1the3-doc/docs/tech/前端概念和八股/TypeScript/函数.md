# å‡½æ•°

interface å¯ä»¥ç”¨æ¥å£°æ˜å‡½æ•°

interface ä¹Ÿå¯ä»¥ç”¨æ¥çº¦æŸ ts classï¼Œä½†æ˜¯ä½¿ç”¨ implements å…³é”®å­—

```js
// å¯¹å‡½æ•°çš„å£°æ˜
interface MyFunc {
    (param1: string, param2: number): boolean;
}

let func: MyFunc;
func = (param1: string, param2: number) => true;

// å¯¹ç±»çš„å£°æ˜
interface MyClassConstructor {
  // è¦†ç›–new
  new (prop1: string, prop2: number);

  myMethod(param1: string): void;
}



// ç”¨implementså…³é”®å­—æ‰èƒ½bindç±»å’Œæ¥å£
class MyClass implements MyClassConstructor {
  constructor(prop1: string, prop2: number) {
    // construct code.
    }
  myMethod(param1: string) {
    // method code.
    }
}
```

## å‡½æ•°ç±»å‹ç›´æ¥å£°æ˜

ä¸¤ç§, ç¬¬ä¸€ç§ç®­å¤´è¡¨è¾¾éœ€è¦å˜é‡æ¥ä½
ç¬¬äºŒç§ç›´æ¥ç”¨ function å£°æ˜ï¼Œä¸éœ€è¦ä½¿ç”¨ç®­å¤´

```js
const fun1: (a: number) => number = (a) => {
  return a;
};

function fun2(a: number): number {
  return a;
}

// åŒ¿åå‡½æ•°
const fun3 = function (a: number) {
  // TSä¼šæ ¹æ®å‡½æ•°ä½“çš„ä»£ç inferå‡ºè¿”å›å€¼ä¸ºnumberç±»å‹
  return a;
};
```

**å¤§éƒ¨åˆ†æƒ…å†µè¿”å›ç»“æœå¯ä»¥ç›´æ¥æ¨å¯¼**
å½“ä½ éœ€è¦å¯¹å‡½æ•°çš„è¿”å›å€¼è¿›è¡Œä¸¥æ ¼é™åˆ¶ï¼Œä»¥ä¿è¯åœ¨ä»¥åçš„æ›´æ–°ä¸­èƒ½å¤Ÿé¿å…å‡½æ•°ä¸­æ–°å¢ return åˆ†æ”¯ä¸ç¬¦åˆæœŸæœ›è¾“å‡ºçš„è¦æ±‚æ—¶ï¼Œå»ºè®®å¹¶ä¸”åº”å½“å¯¹è¿”å›å€¼ç±»å‹è¿›è¡Œæ˜¾å¼çš„å£°æ˜

é™¤äº†å‰é¢ä½¿ç”¨ interface ä¹¦å†™å‡½æ•°çš„ Typeï¼Œè¿˜å¯ä»¥ç”¨ä»¥ä¸‹æ–¹å¼ï¼Œä¹Ÿæ›´æ¨èä½¿ç”¨è¿™ç§æ–¹å¼ï¼ˆtypeï¼‰ï¼š

```js
type MyFunc = (param1: string, param2: number) => boolean;

let myFunc: MyFunc;
myFunc = (param1: string, param2: number) => true;
```

### `type+{()}`

```js
type FooFunc = {
  (arg: string): boolean;
}

è¿™ç§æ–¹å¼çš„å¥½å¤„æ˜¯å¯ä»¥å¾€å‡½æ•°å¯¹è±¡ä¸ŠæŒ‚ä¸œè¥¿ï¼š

type DescribableFunction = {
    description: string;
    (someArg: number): boolean;
};


function doSomething(fn: DescribableFunction) {
console.log(fn.description + " returned " + fn(6));
}
```

### ä¸è¦åœ¨ type æˆ– interface ä¸­ä½¿ç”¨å‡½æ•°å£°æ˜

ä¿æŒä¸€è‡´æ€§ï¼Œç±»å‹/æ¥å£çš„æ‰€æœ‰æˆå‘˜éƒ½é€šè¿‡ç›¸åŒçš„è¯­æ³•å®šä¹‰ã€‚
--strictFunctionTypes åœ¨æ¯”è¾ƒå‡½æ•°ç±»å‹æ—¶å¼ºåˆ¶æ‰§è¡Œæ›´ä¸¥æ ¼çš„ç±»å‹æ£€æŸ¥ï¼Œä½†ç¬¬ä¸€ç§å£°æ˜æ–¹å¼ä¸‹ä¸¥æ ¼æ£€æŸ¥ä¸ç”Ÿæ•ˆã€‚

```js
âœ…
interface ICounter {
  start: (value: number) => string
}
âŒ
interface ICounter1 {
  start(value: number): string
}


ğŸŒ°
interface Animal {}
interface Dog extends Animal {
  wow: () => void
}


interface Comparer<T> {
  compare: (a: T, b: T) => number
}
declare let animalComparer: Comparer<Animal>
declare let dogComparer: Comparer<Doganimal>
Comparer = dogComparer // Error
dogComparer = animalComparer // Ok


interface Comparer1<T> {
  compare(a: T, b: T): number
}
declare let animalComparer1: Comparer1<Animal>
declare let dogComparer1: Comparer1<Doganimal>
Comparer1 = dogComparer // Ok
dogComparer1 = animalComparer // Ok
```

### å¦‚æœå‡½æ•°å‚æ•°æ˜¯å¯é€‰å€¼çš„æƒ…å†µ

```js
// å»ºè®®å°†å¯é€‰å‚æ•°å°½å¯èƒ½åœ°æ”¾åœ¨å‚æ•°åˆ—è¡¨çš„é åçš„ä½ç½®, ä¸ç„¶å–çš„æ—¶å€™è¦å–ç©ºå€¼,æˆ–è€…ç»“æ„è®¾ç½®placeholder
type MyFunc = (param1: string, param2?: number) => void;
// ç»™å‚æ•°è®¾å®šé»˜è®¤å€¼
type MyFunc2 = (param1: string, param2 = 0) => void;
```

### å¦‚æœå‚æ•°çš„æ•°é‡ä¸ç¡®å®š

```js
// å‰è‹¥å¹²å‚æ•°ç¡®å®šï¼Œä½†åç»­å‚æ•°ä¸ç¡®å®š
type MyFunc = (p1: string, p2: number, ...rest: (string | number)[]) => void;
// Array.push type
// å…ˆå°†å‚æ•°ç”¨æ‰©å±•è¿ç®—ç¬¦åˆæˆä¸ºä¸€ä¸ªæ•°ç»„ï¼Œå†å®šä¹‰ç±»å‹T[]
ArrayPush = <T>(...items: T[]) => number;
```

## å¦‚æœå‚æ•°æœ‰å¾ˆå¤šï¼Œå¹¶ä¸”éƒ½æ˜¯ç¡®å®šçš„

ä¸æ¨èç›´æ¥åœ¨å‚æ•°åˆ—è¡¨ç½—åˆ—å‡ºæ‰€æœ‰è¿™äº›å‚æ•°ï¼Œæ›´å¥½çš„å®è·µæ–¹æ¡ˆæ˜¯å°†è¿™äº›å‚æ•°æ”¾åˆ°ä¸€ä¸ª object ä¸­è¿›è¡Œä¼ é€’ï¼Œè€Œå¯¹è¿™ä¸ª object çš„å£°æ˜ï¼Œå»ºè®®æå–æˆ interface

è¿™æ ·åšæ˜¯ä¸ºäº†è®©æˆ‘ä»¬çš„å‡½æ•°å®šä¹‰æ˜¾å¾—æ›´åŠ æ¸…æ™°ï¼Œå¹¶ä¸”åœ¨æœªæ¥éœ€è¦æ·»åŠ æ›´å¤šå‚æ•°æ—¶ï¼Œèƒ½å¤Ÿæ›´åŠ åœ°æ–¹ä¾¿å¿«æ·ã€‚

```js
interface IOptions {
  foo: string;
  bar?: number;
  foofoo: boolean;
  // ...more options
  // also using index to support dynamic options
  [optionKey: string]: any;
}

type MyFunc = (options: IOptions) => void;

// åœ¨å–å‚æ•°çš„æ—¶å€™ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨è§£æ„çš„å½¢å¼æ¥è¿›è¡Œ
function myFunc({
  foo,
  bar = 100, // ä½¿ç”¨è¿™ç§æ–¹å¼åœ¨è®¾å®šç¼ºçœå€¼
  foofoo,
  ...rest
}: IOptions) {
  // function body.
}
```

## è¦å¯¹å‡½æ•°çš„ this è¿›è¡Œå£°æ˜

ActualThisType

```js
function MyFunc(this: ActualThisType, param1: string, param2: number) {
  this; // ActualThisType
}
```

éœ€è¦æ˜¾å¼å£°æ˜ this çš„ç±»å‹çš„æƒ…å†µï¼Œä¸€èˆ¬æ˜¯åœ¨ä»£ç é€»è¾‘ä¸­ï¼Œæˆ‘ä»¬å°†å‡½æ•°çš„ä¸Šä¸‹æ–‡è¿›è¡Œäº†é‡æ–°ç»‘å®šæ—¶ã€‚
ç®­å¤´å‡½æ•°ä¸èƒ½æ˜¾å¼åœ°å£°æ˜ thisï¼Œæ¯•ç«Ÿç®­å¤´å‡½æ•°æ²¡æœ‰å±äºè‡ªå·±çš„ thisã€‚

## é‡è½½å‡½æ•°

å½“æˆ‘ä»¬çš„å‡½æ•°é€»è¾‘éœ€è¦å¯¹å‚æ•°è¿›è¡Œé‡è½½æ—¶ï¼Œå…ˆç”¨ widest çš„å£°æ˜æ–¹æ¡ˆæ¥å¯¹å‡½æ•°è¿›è¡Œå®ç°ï¼Œç„¶ååœ¨å‡½æ•°çš„å®ç°éƒ¨åˆ†ç´§é‚»çš„ä¸Šæ–¹å¯¹é‡è½½çš„å½¢å¼è¿›è¡Œé¢å¤–çš„å£°æ˜ï¼Œé‡è½½éƒ¨åˆ†çš„å£°æ˜å¿…é¡»æ˜¯å®ç°éƒ¨åˆ†å£°æ˜çš„ sub caseï¼š

```js
function emit(eventName: 'event1', param1: string, param2: number): void;
function emit(eventName: 'event2', param1: boolean): void;
function emit(eventName: string, ...params: any[]): void {// function implements.
}

// å¯¹ç±»æ–¹æ³•çš„é‡è½½å†™æ³•
class MyClass {
  // thisæ”¯æŒé“¾å¼è°ƒç”¨
  on(eventName: 'event1', eventListener: (param1: string, param2: number) => void):this;
  on(eventName: 'event2', eventListener: (param1: boolean) => void): this;
  on(eventName: string, eventListener: (...params: any[]) => void): this {
    // method implements.
    }
}

```
